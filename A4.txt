----------------------- OBSTACLE CHALLENGE -----------------------
print(inventor_hub.battery.voltage())
wait(1000)

# Variable global inicial
counter_variacion_angulos = 0

def retroceso(tiempo):
    car.drive_power(-30)
    wait(tiempo)
    car.drive_power(0)
   
def giro_con_imu(steering, angulo_obj, vel):

    global counter_variacion_angulos

   
    # ahora ya puedes usar heading/reset_heading
    angulo_final = angulo_obj + counter_variacion_angulos

    car.drive_power(vel)
    car.steer(steering) 

    if steering > 0:
        # girando hacia la derecha (heading aumenta)
        while inventor_hub.imu.heading() > angulo_final:
            wait(5)
    else:
        # girando hacia la izquierda (heading disminuye)
        while inventor_hub.imu.heading() < angulo_final:
            wait(5)

    car.steer(0)

def alto_temporal(): ###PARA STOP DE PRUEBAS
    car.drive_power(0)
    wait(10000)

def Distancia_Frontal():
    sensor_esq_izq, sensor_esq_der, sensor_front = pr.call('dists')
    
    return sensor_front

def Dist_izq():
    sensor_esq_izqr, sensor_esq_der, sensor_front = pr.call('dists')
   
    return sensor_esq_izqr

def Dist_der():
    sensor_esq_izq, sensor_esq_der, sensor_front = pr.call('dists')
    
    return sensor_esq_der
####Counter funciones###
def Salida_CounterR():
    print("Salida_CounterR")
    car.drive_power(40)
    car.steer(35)
    while not inventor_hub.imu.heading() <= -51: ####AJUSTE PARA QUEDAR VIENDO A PIEZAS EN COLUMNA 1
        wait(5)
    car.drive_power(0)
    wait(1000)
def Counter_V_R1():
    print("Counter_V_R1")
    giro_con_imu(-35, 18, 20)
    car.drive_power(30)
    wait(1000
    giro_con_imu(-35,  -90, 20)
    car.drive_power(0)
    car.steer(2)
    wait(250)
def Counter_V_V1():
    if counter_variacion_angulos <= -85:
        giro_con_imu(35, -65, 20 )
        print("giro ajustado ")
    else:
        print("nelson")
        giro_con_imu(35, -45, 20 )
    print("Counter_V_V1")
        sensor_esq_der= Dist_der()
        wait(0)
    giro_con_imu(25, -80, 20)
    car.steer(-4)
    car.drive_power(0)
def Counter_V3_N1():
    print("Counter_V3_N1")
    print(counter_variacion_angulos)
    car.steer(-13
    print("Distancia frontal V3_N1 " + str(sensor_front))
    giro_con_imu(35, -84, 20)
    car.steer(-4)
    car.drive_power(0)
def Counter_SR_V1():
    print("Counter_SR_V1")
    car.steer(-7)
    if counter_variacion_angulos <= -85:
        print("ajustado")
        giro_con_imu(35, -109,20)
        car.steer(-4)
    else:
        print("nelson")
        giro_con_imu(30, -100, 20 )
    print(inventor_hub.imu.heading())
    car.steer(0)
    sensor_front = Distancia_Frontal()
    while not sensor_front <= 600: ###usar el sensor derecho
        sensor_front = Distancia_Frontal()
        wait(5)
    retroceso(1000)
    giro_con_imu(40, -86, 25)
    car.drive_power(25)
    car.steer(-8)
    car.drive_power(0)
    wait(250)
    print("termine SR V1")
def Counter_EVASION():
    global counter_tipo_giro, fin
    car.drive_power(30)

    while True:
        # --- LECTURAS FRESCAS EN CADA VUELTA ---
        dist_front = Distancia_Frontal()
        izq_mm = sensor_izq.distance()
        block_ID, x, y, ancho, alto = Color_Bloque()

        # Normaliza tipos por si vienen como string/None
        try:
            block_ID = int(block_ID)
        except:
            block_ID = 0
        alto = int(alto or 0)

    

        # --- Â¿BLOQUE DETECTADO? ---
        if (block_ID in (1, 2)) and (alto > UMBRAL_ALTO):
            if block_ID == 1:
                print("Obstaculo Verde")
                Counter_EVASION_VERDE()
                counter_tipo_giro = 1
            else:
                print("Obstaculo Rojo")
                Counter_EVASION_ROJA()
                counter_tipo_giro = 2
            fin = 1
            break

        # --- âNO VEO NADAâ (lateral lejos y algo delante) ---
        if (izq_mm > UMBRAL_LEJOS) and (dist_front < UMBRAL_LEJOS):
            # Acerca hasta que el frente estÃ© < UMBRAL_FRONT1
            while True:
                dist_front = Distancia_Frontal()
                if dist_front < UMBRAL_FRONT1 and izq_mm > UMBRAL_LEJOS:
                    break
                wait(10)

            print("no veo nada")
            retroceso(2000)
            # Avanza y confirma giro hacia central
            if counter_variacion_angulos <= -616:
                parqueo()
            car.steer(-4)
            car.drive_power(25)
            wait(1500)
            block_ID, x, y, ancho, alto = Color_Bloque()
            if block_ID == 1:
                car.drive_power(0)
                car.steer(-6)
                counter_tipo_giro=2
                fin = 1
            else:
                car.steer(4)
                car.drive_power(20)
                counter_tipo_giro=2
                fin = 1
            print("LLegada central")
            
            break

----------------------- OPEN CHALLENGE -----------------------
total_lados = 12
reposiciones_lado = [{'izquierda': 0, 'derecha': 0, 'ratios': [], 'lecturas': []} for _ in range(total_lados)]
tiempo_inicios_giro = []
tiempo_entre_deteccion_y_giro = []
indice_lado_actual = 0

async def subtask():
    async def get_filtered_distance(sensor, nombre):
        readings = []
        while len(readings) < 7:
            if cancelar_lecturas:
                return 0
            value = await sensor.distance()
            if value <= 1000:
                readings.append(value)
            await wait(10)
        readings.remove(max(readings))
        readings.remove(min(readings))
        return sum(readings) / len(readings)

    while True:
        await wait(0)
        if cancelar_lecturas:
            return

        dist_derecho = await get_filtered_distance(d_derecho, "derecho")
        dist_izquierdo = await get_filtered_distance(d_izquierdo, "izquierdo")


        if Direction==0:####REPOSICIONES EN PRIMER CARRIL#####
            pass
            diferencia_distancia=dist_derecho-dist_izquierdo
            if -100<diferencia_distancia<100:
               pass
            elif -100>=diferencia_distancia:
                car.steer(15); await wait(600)
                
            elif 100<diferencia_distancia:
                car.steer(-13); await wait(650)
          
            else:
                pass
            
            
        elif Direction == 10:  #REPOSICIONES EN DIRECCION COUNTERCLOCKWISE
            if dist_izquierdo == 0:
                ratio = 1
            else:
                ratio = dist_derecho / dist_izquierdo

            if ratio < ratio_inferior_counterclockwise:
                print(str(ratio) + "tu")
                reposiciones_lado[indice_lado_actual]['izquierda'] += 1
                reposiciones_lado[indice_lado_actual]['ratios'].append(ratio)
                reposiciones_lado[indice_lado_actual]['lecturas'].append((dist_derecho, dist_izquierdo))
                
                car.steer(15); await wait(850)

            elif ratio > ratio_superior_counterclockwise:
                print(str(ratio) + "yo")
                reposiciones_lado[indice_lado_actual]['derecha'] += 1
                car.steer(-3); await wait(500)
        else:  #REPOSICIONES EN DIRECCION CLOCKWISE
            if dist_derecho == 0 or dist_izquierdo==0:
                ratio = 1
            else:
                ratio = dist_derecho / dist_izquierdo

            if ratio < ratio_inferior_clockwise:
                print(str(ratio) + "yo")
                reposiciones_lado[indice_lado_actual]['izquierda'] += 1
            elif ratio > ratio_superior_clockwise:
                print(str(ratio) + "tu")
                reposiciones_lado[indice_lado_actual]['derecha'] += 1
                car.steer(-5); await wait(600)# tiene 500ms mas solo para ver si ayuda. original 250

async def subtask2():
    global Primera_Linea, Direction, cancelar_lecturas
    reloj_inicio_giro = StopWatch(); reloj_inicio_giro.reset()
    # Espera Ãºnicamente el color que corresponde segÃºn la direcciÃ³n
    while not (
        (Direction == 10 and Min_H_Azul <= (await color_sensor.hsv())[0] <= Max_H_Azul) or
        (Direction == 20 and Min_H_Rojo <= (await color_sensor.hsv())[0] <= Max_H_Rojo) or
        (Direction == 0 and (Min_H_Azul <= (await color_sensor.hsv())[0] <= Max_H_Azul or Min_H_Rojo <= (await color_sensor.hsv())[0] <= Max_H_Rojo))
    ):

        await wait(0)
        inventor_hub.light.on(await color_sensor.hsv())
        await wait(0)

    tiempo_inicios_giro.append(reloj_inicio_giro.time())
    cancelar_lecturas = True
    if Primera_Linea == 0:
        hsv = await color_sensor.hsv()
        Primera_Linea = 1
        Direction = 10 if Min_H_Azul <= hsv[0] <= Max_H_Azul else 20
    await wait(100)

async def Clockwise():
    global Limite_inferior_Clockwise, Limite_superior_Clockwise
    reloj = StopWatch(); reloj.reset()
    confirmaciones = 0
    car.steer(9)
    wait(100)#ORIGINAL 500
    while reloj.time() < TIEMPO_MAX_ESPERA_SENSOR:
        lectura = await d_derecho.distance()
        if lectura > 800:
            confirmaciones += 1
            if confirmaciones >= 20:
                print("Giro confirmado derecha clockwise")
                break
        else:
            confirmaciones = 0  # Reinicia si se recibe una lectura vÃ¡lida
        await wait(10)

    tiempos_espera_derecho.append(reloj.time())
    lecturas_finales_derecho.append(await d_derecho.distance())
    tiempo_entre_deteccion_y_giro.append(tiempo_inicios_giro[-1])

#EJECUCION DEL GIRO
    car.steer(-40); await wait(50)
    while not Limite_inferior_Clockwise <= inventor_hub.imu.heading():
        await wait(0)
    print(inventor_hub.imu.heading())
    car.steer(-3); await wait(espera_salida_giro) #####POSICION LUEGO DE GIRAR
