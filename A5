# Variable global inicial
counter_variacion_angulos = 0


   
def giro_con_imu(steering, angulo_obj, vel):

    global counter_variacion_angulos

   
    # ahora ya puedes usar heading/reset_heading

    # Ajustar el Ã¡ngulo objetivo con la variaciÃ³n global
    angulo_final = angulo_obj + counter_variacion_angulos

    car.drive_speed(vel*10)
    car.steer(steering) 

    if steering > 0:
        # girando hacia la derecha (heading aumenta)
        while inventor_hub.imu.heading() > angulo_final:
            wait(5)
    else:
        # girando hacia la izquierda (heading disminuye)
        while inventor_hub.imu.heading() < angulo_final:
            wait(5)

    car.steer(0)

def alto_temporal(): ###PARA STOP DE PRUEBAS
    car.drive_power(0)
    wait(10000)

# -------------------- LECTURAS FILTRADAS (5 mediciones) --------------------
# Regla: tomar 5 vÃ¡lidas (0..1000 mm), descartar >1000 mm, eliminar el mayor y el menor, promediar las 3 restantes.
def _filtered_read(idx):
    """
    Lee el canal idx (0=izq, 1=der, 2=front) con 5 mediciones vÃ¡lidas (<=1000 mm),
    elimina la mayor y la menor y devuelve el promedio de las 3 restantes.
    Si no logra 5 vÃ¡lidas, usa el mejor esfuerzo (trimmed si >=3, si no promedio simple).
    """
    vals = []
    intentos = 0
    while len(vals) < 5 and intentos < 20:
        try:
            izq, der, front = pr.call('dists')  # formato 'hhh' en mm
            arr = (izq, der, front)
            v = int(arr[idx])
            if 0 <= v <= 1000:
                vals.append(v)
        except:
            pass
        wait(10)
        intentos += 1

    if len(vals) >= 5:
        vals.sort()
        core = vals[1:-1]       # quita menor y mayor
        return sum(core) // 3   # promedio de 3 valores (entero mm)
    elif len(vals) >= 3:
        vals.sort()
        core = vals[1:-1]
        if core:
            return sum(core) // len(core)
        return sum(vals) // len(vals)
    elif len(vals) > 0:
        return sum(vals) // len(vals)

    return 9999  # fallback âmuy lejosâ si no hubo vÃ¡lidas

def Distancia_Frontal():
    return _filtered_read(2)

def Dist_izq():
    return _filtered_read(0)

def Dist_der():
    return _filtered_read(1)
# --------------------------------------------------------------------------

####Counter funciones###
def Salida_CounterR():
    print("Salida_CounterR")
    car.drive_speed(200)
    car.steer(-50)
    while not inventor_hub.imu.heading() >= -60: ####EVASION DE BLOQUES
        wait(5)
    car.steer(-5)
    wait(2900)
    print(inventor_hub.imu.heading())
    car.drive_speed(100)
    car.steer(40)
    while not inventor_hub.imu.heading() <= -59: ####AJUSTE PARA QUEDAR VIENDO A PIEZAS EN COLUMNA 1
        wait(5)
    car.drive_power(0)
    car.steer(-8)
    wait(1000)
def Counter_V_R1():
    print("Counter_V_R1")
    giro_con_imu(-35, 25, 20)
    car.drive_speed(180)
    giro_con_imu(30, 6, 20)
    car.steer(-4)
    car.drive_speed(200)
    sensor_front = Distancia_Frontal()
    while not sensor_front <= 350:
        sensor_front = Distancia_Frontal()
        wait(5)
    giro_con_imu(36, -45, 30)
    giro_con_imu(45,-150,20)
    print(sensor_izq.distance())
    car.drive_speed(150)
    sensor_front= Distancia_Frontal()
    while not sensor_front <= 550: #si se quiere centrar mas de cambia el valor de esto 
        sensor_front= Distancia_Frontal()
    print(sensor_front)
    giro_con_imu(-40,  -93, 20)
    car.drive_power(0)
    car.steer(2)
    wait(250)
def Counter_V_V1():
    if counter_variacion_angulos <= -85:
        giro_con_imu(35, -65, 20 )
        print("giro ajustado ")
    else:
        print("nelson")
        giro_con_imu(35, -45, 20 )
    print("Counter_V_V1")
    car.drive_power(30)
    car.steer(-5)
    wait(2100) #####AVANCE####
    giro_con_imu(-30, -45, 20)
    car.drive_power(20)
    sensor_esq_der= Dist_der()
    while not sensor_esq_der <= 2000: #si se quiere centrar mas de cambia el valor de esto 
        sensor_esq_der= Dist_der()
        wait(0)
    giro_con_imu(25, -80, 20)
    car.steer(-4)
    car.drive_power(0)
def Counter_V3_N1():
    print("Counter_V3_N1")
    print(counter_variacion_angulos)
    car.steer(-13)
    car.drive_power(25)
    sensor_front = Distancia_Frontal()
    while not Min_H_Rojo <= (color_sensor.hsv())[0] <= Max_H_Rojo:
                wait(5)
    print("Distancia frontal V3_N1 " + str(sensor_front))
    giro_con_imu(35, -84, 20)
    car.steer(-4)
    car.drive_power(0)
def Counter_SR_V1():
    print("Counter_SR_V1")
    car.steer(-4.8)
    if counter_variacion_angulos <= -85:
        print("ajustado")
        giro_con_imu(37,-105,20)
    else:
        print("nelson")
        giro_con_imu(37, -105, 20 )
    print(inventor_hub.imu.heading())
    car.drive_speed(200)
    sensor_esq_iz = Dist_izq()
    sensor_front = Distancia_Frontal()
    while not (sensor_esq_iz <= 350): ###usar el sensor izquierdo
        sensor_esq_iz = Dist_izq() 
        sensor_front = Distancia_Frontal()
    print(sensor_esq_iz)
    giro_con_imu(-35, -20, 25)
    car.drive_speed(100)
    car.steer(0)
    sensor_esq_der = Dist_der()
    while not sensor_front <= 600: ###usar el sensor derecho
        sensor_front = Distancia_Frontal()
        wait(5)
    giro_con_imu(40, -87, 25)
    car.drive_power(25)
    car.steer(-3)
    car.drive_power(0)
    print("termine SR V1")
def Counter_EVASION():
    global counter_tipo_giro, fin

    # umbrales (ajÃºstalos a tu campo)
    UMBRAL_ALTO = 50
    UMBRAL_LEJOS = 1000
    UMBRAL_FRONT1 = 900
    UMBRAL_FRONT2 = 700

    fin = 0
    car.drive_power(30)

    while True:
        # --- LECTURAS FRESCAS EN CADA VUELTA ---
        dist_front = Distancia_Frontal()
        izq_mm = sensor_izq.distance()
        block_ID, x, y, ancho, alto = Color_Bloque()

        # Normaliza tipos por si vienen como string/None
        try:
            block_ID = int(block_ID)
        except:
            block_ID = 0
        alto = int(alto or 0)

    

        # --- Â¿BLOQUE DETECTADO? ---
        if (block_ID in (1, 2)) and (alto > UMBRAL_ALTO):
            if block_ID == 1:
                print("Obstaculo Verde")
                Counter_EVASION_VERDE()
                counter_tipo_giro = 1
            else:
                print("Obstaculo Rojo")
                Counter_EVASION_ROJA()
                counter_tipo_giro = 2
            fin = 1
            break

        # --- âNO VEO NADAâ (lateral lejos y algo delante) ---
        if (izq_mm > UMBRAL_LEJOS) and (dist_front < UMBRAL_LEJOS):
            # Acerca hasta que el frente estÃ© < UMBRAL_FRONT1
            while True:
                dist_front = Distancia_Frontal()
                if dist_front < UMBRAL_FRONT1 and izq_mm > UMBRAL_LEJOS:
                    break
                wait(10)

            print("no veo nada")
            # Avanza y confirma giro hacia central
            if counter_variacion_angulos <= -616:
                parqueo()
            car.steer(-4)
            car.drive_power(25)
            while Distancia_Frontal() >= UMBRAL_FRONT2:
                wait(10)
            giro_con_imu(35, -170, 20)
            car.steer(-5)
            car.drive_power(-15)
            wait(1500)
            car.drive_power(20)
            while not Min_H_Rojo <= (color_sensor.hsv())[0] <= Max_H_Rojo:
                wait(5)
            car.drive_power(-20)
            wait(500)
            car.drive_power(0)
            counter_tipo_giro=2
            fin = 1
            print("LLegada central")
            
            break

        # --- seguir buscando ---
        wait(20)

    print("Bucle finalizado")
    wait(20)
def Counter_SR_N1():
    print("Counter_SR_N1")
    car.drive_power(25)
    car.steer(-10)
    sensor_esq_der= Dist_der()
    while not sensor_esq_der <= 900: #si se quiere centrar mas de cambia el valor de esto 
        sensor_esq_der= Dist_der()
        wait(0)
            
    giro_con_imu(40, -85, 25)
    
    car.drive_power(0)
    car.drive_power(-20)
    car.drive_power(0)
def Counter_R3_N1():
    global counter_variacion_angulos

    print("Counter_R3_N1")
    car.steer(-4.8)
    car.drive_speed(200)
    wait(2000)
    dist_iz = sensor_izq.distance()
    while dist_iz >= 600:
        dist_iz = sensor_izq.distance()
        wait(5) 
    print(sensor_izq.distance())
    car.drive_power(0)
    print(inventor_hub.imu.heading())
    if counter_variacion_angulos == 0:
        Counter_SR_N1()
def parqueo():
    ("Parqueo")
    car.drive_power(20)
    wait(700)
    car.drive_power(0)
    car.steer(-38)
    car.drive_power(-40)
    while not inventor_hub.imu.heading() <= -785:
        wait(5)
    print(inventor_hub.imu.heading())
    car.steer(5)
    dist_fr = Distancia_Frontal()
    while not dist_fr > 900:
        dist_fr = Distancia_Frontal()
    car.drive_power(0)
    wait(60000)
def Counter_SV_N1():
    print("Counter_SV_N1")
    print(counter_variacion_angulos)
    giro_con_imu(-25, -25,25)
    car.drive_power(35)
    sensor_front = Distancia_Frontal()
    while not 520<= sensor_front <= 535: #si se quiere centrar mas de cambia el valor de esto 
        sensor_front = Distancia_Frontal()
    print("Distancia antes de girar SV_N1 " + str(sensor_front))
    giro_con_imu(30, -85, 20)
    car.steer(-5)
    car.drive_power(0)
def Counter_EVASION_VERDE():
    global counter_tipo_giro, fin 
    print("Evasion verde")
    car.drive_power(20)
    giro_con_imu(30, -140, 20)
    car.steer(-3)
    esq_izq= Dist_izq()
    while not esq_izq <=200 : #si se quiere centrar mas de cambia el valor de esto 
        esq_izq= Dist_izq()
        wait(5)
    giro_con_imu(-30, -97, 20)  
    car.drive_speed(200)
    car.steer(-1)
    print(inventor_hub.imu.heading())
    sensor_front = Distancia_Frontal()
    while not (sensor_front <= 1100 and (Min_H_azul <= (color_sensor.hsv())[0] <= Max_H_azul)):
        sensor_front = Distancia_Frontal()
        wait(5)
    if inventor_hub.imu.heading() <= -700:
        print("Parqueo")
        parqueo()
    else:
        print("ya")
        car.drive_power(20)
        giro_con_imu(30, -113, 15)
        car.drive_power(0)
        counter_tipo_giro = 1
        fin = 1
        print("llegada esquina")
        wait(250)
def Counter_EVASION_ROJA():
    global counter_tipo_giro, fin, counter_variacion_angulos, muro 
    if counter_variacion_angulos <= -261 and muro == 0 :
        print("muro")
        giro_con_imu(-25, -70, 20)
        wait(2500)
        giro_con_imu(25, -90, 20)
        car.drive_power(40)
        car.steer(-16)
        sensor_front= Distancia_Frontal()
        while not 575 <= sensor_front <= 625:
            sensor_front = Distancia_Frontal()
            wait(5)
        giro_con_imu(40, -175, 20)
        car.drive_power(35)
        car.steer(-4)
        car.drive_power(-20)
        wait(1000)
        block_ID, x, y, ancho, alto = Color_Bloque()
        if block_ID == 1:
                car.drive_power(-20)
                wait(500)
                car.drive_power(0)
                car.steer(-4.8)
                counter_tipo_giro=2
                fin = 1
        else:
            car.steer(-4.8)
            car.drive_power(20)
            while not Min_H_Rojo <= (color_sensor.hsv())[0] <= Max_H_Rojo:
                wait(5)
            car.drive_power(0)
            car.steer(-4.8)
            counter_tipo_giro=2
            fin = 1
    else:
        if counter_variacion_angulos <= -616:
            giro_con_imu(-25, -70, 20)
            wait(2000)
            giro_con_imu(25, -90, 20)
            sensor_front= Distancia_Frontal()
            while not sensor_front <= 1000: #si se quiere centrar mas de cambia el valor de esto 
                sensor_front= Distancia_Frontal()
                wait(5)
            parqueo()
        else:
            print("evasion roja")
            car.drive_power(20)
            giro_con_imu(-35, -40, 20)
            car.steer(-3)
            sensor_der = Dist_der()
            while not sensor_der <= 250: #si se quiere centrar mas de cambia el valor de esto ponerle or aqui
                sensor_der = Dist_der()
                wait(0)
            giro_con_imu(35, -80, 20)
            car.steer(-4.8 )
            wait(250)
            car.drive_speed(200)
            sensor_front = Distancia_Frontal()
            while not 615 <= sensor_front <= 630 : #si se quiere centrar mas de cambia el valor de esto 
                sensor_front = Distancia_Frontal()
                wait(0)
            print("pared y giro "+str(sensor_front))
            giro_con_imu(35, -164   , 20)
            car.steer(-4.8)
            car.drive_power(30)
            while not Min_H_Rojo <= (color_sensor.hsv())[0] <= Max_H_Rojo:
                wait(5)
            car.drive_speed(-200)
            wait(1500)
            block_ID, x, y, ancho, alto = Color_Bloque()
            if block_ID == 1:
                car.drive_power(0)
                car.steer(-4.8)
                counter_tipo_giro=2
                fin = 1
            else:
                car.steer(-4.8)
                car.drive_speed(200)
                while not Min_H_Rojo <= (color_sensor.hsv())[0] <= Max_H_Rojo:
                    wait(5)
                car.drive_power(0)
                car.steer(-4.8)
                counter_tipo_giro=2
                fin = 1
            print("LLegada central")
def Counter_SR_R1():
    print("Counter_SR_R1")
    car.drive_power(-25)
    wait(500)
    car.drive_power(25)
    giro_con_imu(-38, -25, 25)
    car.steer(0)
    sensor_front = Distancia_Frontal()
    while not sensor_front <= 400: #si se quiere centrar mas de cambia el valor de esto 
        sensor_front = Distancia_Frontal()
        wait(0)
    giro_con_imu(40, -90, 25)    
    car.steer(0)
    while not sensor_izq.distance() < 1000:
        
        wait(5)
    print(sensor_izq.distance())  
    giro_con_imu(32, -140, 25)
    car.steer(0)
    sensor_front = Distancia_Frontal()
    while not sensor_front <= 600: #si se quiere centrar mas de cambia el valor de esto 
        sensor_front = Distancia_Frontal()
        wait(0)
    giro_con_imu(-30, -95, 25)
    car.steer(0)
def Salida_CounterV():
    print("Salida_CounterV")
    car.drive_power(22)
    car.steer(30)
    while not inventor_hub.imu.heading() <= -120 :
        wait(0)
    car.steer(-30)
    while not inventor_hub.imu.heading() >= -90 :
        wait(5)
    car.steer(10)
    sensor_front= Distancia_Frontal()
    while not sensor_front <= 250:
        sensor_front= Distancia_Frontal()
    car.steer(-40)
    while not inventor_hub.imu.heading() >=-10:
        wait(5)   

    car.steer(4)
    dist_front= Distancia_Frontal()  
    while not Min_H_azul <= (color_sensor.hsv())[0] <= Max_H_azul:
                wait(5)
    giro_con_imu(35, -15,20)
    print(dist_front)
    car.drive_power(0)
    wait(200)   
def Salida_Counter():
    print("Salida_Counter")
    car.steer(55)
    wait(300)
    car.drive_speed(100)
    while not inventor_hub.imu.heading() <= -70 * 0.94:
        wait(5)
        
    car.drive_power(0)
    wait(500)
def Color_Bloque():
    block_ID, x, y, ancho, alto = pr.call('bloqu')
    return block_ID, x, y, ancho, alto
def Counter_navegacion_esquina():
    block_ID, x, y, ancho, alto = Color_Bloque()
    if block_ID == 1 and alto>50:
        print("Primera Columna VERDE")
        Counter_V_V1()#cuando primer y segundo bloque es verde
        wait(250)
        Counter_EVASION()
    elif block_ID == 2 and alto>50:
        print("Primera Columna ROJA")
        Counter_V_R1()#cuando primer bloque es verde y segundo rojo
        wait(250)
        Counter_EVASION()
    else: 
        print("Primera Columna sin Obstaculos") ##AQUI DEBE IR LA FUNCION CUANDO NO HAYA BLOQUE
        if counter_variacion_angulos > -80:
            Counter_SV_N1()
        else:
            Counter_SV_N1()
        wait(250)
        Counter_EVASION()
def Counter_navegacion_central():
    block_ID, x, y, ancho, alto = Color_Bloque()
    if block_ID == 1 and alto>50:
        print("Primera Columna Verde")
        Counter_SR_V1()
        wait(100)#cuando primer bloque es rojo y segundo bloque es verde
        Counter_EVASION()
    elif block_ID == 2 and alto>50:
        print("Primera Columna Roja")
        Counter_SR_R1()
        Counter_EVASION()
    else:  
        print("Primera Columna sin Obstaculos") 
        Counter_R3_N1()
        Counter_EVASION()
####Clock funciones###
def Salida_ClockR():
    print("hacelo")
    giro_con_imu(-35, 70, 30)
    car.drive_power(0)
    print(inventor_hub.imu.heading())
    car.drive_power(25)
    sensor_front = Distancia_Frontal()
    while not sensor_front <= 350:
        sensor_front = Distancia_Frontal()
        wait(5) 
    car.drive_power(0)
    giro_con_imu(35, 5, 30)
    while not sensor_der.distance() >= 1000:
        car.drive_power(20)
    car.drive_power(0)
    giro_con_imu(-40, 20, 10)
def Reposicion_Rojo2():
    giro_con_imu(-35, 60, 20)
    car.drive_power(25)
    sensor_esq_der = Dist_der()
    while not sensor_esq_der <= 350:
        sensor_esq_der = Dist_der()
        wait(5)
    print("Distancia")
    giro_con_imu(35,10, 30)
    dist_fron = Distancia_Frontal()
    while not dist_fron < 1000:
        dist_fron = Distancia_Frontal()
    car.drive_power(0)
    giro_con_imu(-35, 30,30)
    alto_temporal()
def Reposicion_Verde2():
    print("reposicion verde 2")
    giro_con_imu(30, -40, 30)
    giro_con_imu(-30, -10, 25)
    car.steer(-2)
    dist_fron = Distancia_Frontal()
    while not dist_fron < 600:
        dist_fron = Distancia_Frontal()
    car.drive_power(20)
    giro_con_imu(-30, 85, 25)
    car.steer(4)
    while not Min_H_azul <= (color_sensor.hsv())[0] <= Max_H_azul:
            wait(5)
    car.drive_power(-20)
    wait(500)
    car.drive_power(0)
def Salida_ClockN():
    print("llegue")
    car.drive_power(20)
    giro_con_imu(25, 5, 20)
    car.steer(-3)
    car.drive_power(0)
    wait(250)
def Repocicion_Nada2():
    giro_con_imu(30, 0,30)
    sensor_front = Distancia_Frontal()
    while not sensor_front <= 600:
        sensor_front = Distancia_Frontal()
        wait(5)
    giro_con_imu(-35 , 85, 25)
def Reposicion_Verde_Medio():
    giro_con_imu(30, -40, 30)
    car.drive_power(15)
    wait(500)
    giro_con_imu(-30, -5, 25)
    car.steer(5)
    while not  (Min_H_Rojo <= (color_sensor.hsv())[0] <= Max_H_Rojo):
        car.drive_power(20)
    print("vi rojo")
    giro_con_imu(-35, 80, 25)
def Salida_y_lectura():
    car.steer(-45)
    giro_con_imu(-53, 75,30)
    giro_con_imu(35, 40, 30)
    car.drive_power(30)
    car.steer(2)
    car.drive_power(0)
    wait(700)
    car.drive_power(25)
    car.drive_power(0)
def Clock_R_V1():
    print("Clock_R_V1")
    giro_con_imu(35, 10, 30)
    car.drive_power(30)
    wait(500)
    giro_con_imu(-30, -10, 30)
    car.steer(0)
    car.drive_power(30)
    sensor_front = Distancia_Frontal()
    while not sensor_front <= 350:
        sensor_front = Distancia_Frontal()
        wait(5)
    giro_con_imu(-35, 80, 30)
    while not sensor_der.distance() < 1000:
        wait(5)
    giro_con_imu(-40, 150,20)
    print(sensor_der.distance())
    car.drive_power(15)
    sensor_front= Distancia_Frontal()
    while not sensor_front <= 600: #si se quiere centrar mas de cambia el valor de esto 
        sensor_front= Distancia_Frontal()
        wait(5)

    giro_con_imu(35,  97, 15)
    car.drive_power(0)
    car.steer(2)
    wait(250)
def Clock_R_R1():
    print("R_R1 clock")
    if counter_variacion_angulos >= 85:
        giro_con_imu(-35, 130, 20 )
        print("ajustado ")
    else:
        print("nelson")
        giro_con_imu(-35, 120, 20 )
    car.drive_power(25)
    sensor_esq_der = Dist_der()
    while not sensor_esq_der<= 325: ###usar el sensor izquierdo
        sensor_esq_der = Dist_der() 
    print(sensor_esq_der)
    giro_con_imu(35, 25, 25)
    car.drive_power(25)
    car.steer(0)
    sensor_front = Distancia_Frontal()
    while not sensor_front <= 600: ###usar el sensor derecho
        sensor_front = Distancia_Frontal()
        wait(5)
    giro_con_imu(-40, -83, 25)
    car.drive_power(25)
    car.steer(-5)
    car.drive_power(0)
    print("termine R r1")
    car.drive_power(0)
def Clock_R3_N1():
    print("Clock_R3_N1")
    print(counter_variacion_angulos)
    car.steer(5)
    car.drive_power(25)
    sensor_front = Distancia_Frontal()
    while not sensor_front <=750: #si se quiere centrar mas de cambia el valor de esto 
        sensor_front = Distancia_Frontal()
    print("Distancia frontal R3_N1 " + str(sensor_front))
    giro_con_imu(-35, 84, 15)
    car.steer(4)
    car.drive_power(0)
def Clock_SV_R1():
    print("Clock_SV_R1")
    car.steer(7) 
    if counter_variacion_angulos >= 85:
        giro_con_imu(-30, 115, 20 )
        print("giro ajustado ")
    else:
        print("nelson")
        giro_con_imu(-30, 100, 20 )
    print(inventor_hub.imu.heading())
    car.drive_power(25)
    sensor_esq_der = Dist_der()
    while not sensor_esq_der <= 300: ###usar el sensor izquierdo
        sensor_esq_der = Dist_der()
    print(sensor_esq_der)
    giro_con_imu(35, 55, 25)
    car.drive_power(25)
    car.steer(0)
    sensor_esq_izq = Dist_izq()
    while not sensor_esq_izq <= 600: ###usar el sensor derecho
        sensor_esq_izq = Dist_izq()
        wait(5)
    giro_con_imu(-40, 83, 25)
    car.drive_power(25)
    car.steer(-5)
    car.drive_power(0)
    print("termine SV R1")
def Clock_Evasion():
    global counter_tipo_giro, fin

    # umbrales (ajÃºstalos a tu campo)
    UMBRAL_ALTO = 50
    UMBRAL_LEJOS = 1000
    UMBRAL_FRONT1 = 900
    UMBRAL_FRONT2 = 700

    fin = 0
    car.drive_power(20)

    while True:
        # --- LECTURAS FRESCAS EN CADA VUELTA ---
        dist_front = Distancia_Frontal()
        der_mm = sensor_der.distance()
        block_ID, x, y, ancho, alto = Color_Bloque()

        # Normaliza tipos por si vienen como string/None
        try:
            block_ID = int(block_ID)
        except:
            block_ID = 0
        alto = int(alto or 0)

    

        # --- Â¿BLOQUE DETECTADO? ---
        if (block_ID in (1, 2)) and (alto > UMBRAL_ALTO):
            if block_ID == 1:
                print("Obstaculo Verde")
                Clock_EVASION_VERDE()
                counter_tipo_giro = 2
            else:
                print("Obstaculo Rojo")
                Clock_EVASION_ROJA()
                counter_tipo_giro = 1
            fin = 1
            break

        # --- âNO VEO NADAâ (lateral lejos y algo delante) ---
        if (der_mm > UMBRAL_LEJOS) and (dist_front < UMBRAL_LEJOS):
            # Acerca hasta que el frente estÃ© < UMBRAL_FRONT1
            while True:
                dist_front = Distancia_Frontal()
                if dist_front < UMBRAL_FRONT1:
                    break
                wait(10)

            print("no veo nada")
            # Avanza y confirma giro hacia central
            if counter_variacion_angulos >= 616:
                parqueo()
            car.steer(4)
            car.drive_power(20)
            while Distancia_Frontal() >= UMBRAL_FRONT2:
                wait(10)
            giro_con_imu(-35, 176, 20)
            car.steer(-4)
            while not Min_H_azul <= (color_sensor.hsv())[0] <= Max_H_azul:
                wait(5)
            car.drive_power(-20)
            wait(500)
            car.drive_power(0)
            counter_tipo_giro=2
            fin = 1
            print("LLegada central")
            
            break

        # --- seguir buscando ---
        wait(20)
    print("Bucle finalizado")
    wait(20)
def Clock_SV_N1():
    print("Counter_SV_N1")
    car.drive_power(25)
    car.steer(-5)
    sensor_esq_izq= Dist_izq()
    while not sensor_esq_izq <= 600: #si se quiere centrar mas de cambia el valor de esto 
        sensor_esq_izq= Dist_izq()
        wait(0)     
    giro_con_imu(-30, 88, 25)
    
    car.drive_power(0)
    car.drive_power(-20)
    car.drive_power(0)
def Clock_V3_N1():
    print("Counter_V3_N1")
    car.steer(3)
    car.drive_power(20)
    dist_der = sensor_der.distance()
    while dist_der > 1000:
        dist_der = sensor_der.distance()
        wait(5) 
    print(sensor_der.distance())
    car.drive_power(0)
    print(inventor_hub.imu.heading())
def Clock_SR_N1():
    print("Counter_SV")
    print(counter_variacion_angulos)
    giro_con_imu(25, 0,25)
    car.drive_power(25)
    sensor_front = Distancia_Frontal()
    while not sensor_front <=700: #si se quiere centrar mas de cambia el valor de esto 
        sensor_front = Distancia_Frontal()
    print("Distancia antes de girar SV_N1 " + str(sensor_front))
    giro_con_imu(-38, 80, 20)
    wait(250)
    car.steer(-1)
    car.drive_power(0)
def Clock_EVASION_VERDE():
    global counter_tipo_giro, fin, counter_variacion_angulos, muro 
    if counter_variacion_angulos >= 261 and muro == 0 :
        print("muro")
        giro_con_imu(-25, 70, 20)
        wait(2000)
        giro_con_imu(25, -90, 20)
        car.steer(-3)
        sensor_front= Distancia_Frontal()
        while not sensor_front <= 600: #si se quiere centrar mas de cambia el valor de esto 
            sensor_front= Distancia_Frontal()
        giro_con_imu(40, 175, 15)
        car.steer(-4)
        car.drive_power(-20)
        wait(1000)
        block_ID, x, y, ancho, alto = Color_Bloque()
        if block_ID == 2:
            car.drive_power(0)
            car.steer(-4)
            counter_tipo_giro=2
            fin = 1
        else:
            car.steer(4)
            car.drive_power(20)
            while not Min_H_azul <= (color_sensor.hsv())[0] <= Max_H_azul:
                wait(5)
            car.drive_power(0)
            car.steer(-5)
            counter_tipo_giro=2
            fin = 1
        print("LLegada central")
    else:
        if counter_variacion_angulos >= 616:
            giro_con_imu(-25, 70, 20)
            wait(2000)
            giro_con_imu(25, 90, 20)
            sensor_front= Distancia_Frontal()
            while not sensor_front <= 1000: #si se quiere centrar mas de cambia el valor de esto 
                sensor_front= Distancia_Frontal()
                wait(5)
            parqueo()
        else:
            print("evasion verde clock")
            car.drive_power(20)
            giro_con_imu(25, 35, 20)
            car.steer(-4)
            sensor_front= Distancia_Frontal()
            while not sensor_front <= 300: #si se quiere centrar mas de cambia el valor de esto 
                sensor_front= Distancia_Frontal()
                wait(0)
            giro_con_imu(-35, 80, 20)
            car.steer(-2)
            wait(250)
            sensor_front= Distancia_Frontal()
            while not sensor_front <= 600: #si se quiere centrar mas de cambia el valor de esto 
                sensor_front= Distancia_Frontal()
                wait(0)
            giro_con_imu(-35, 175, 15)
            car.steer(4)
            car.drive_power(20)
            while not Min_H_azul <= (color_sensor.hsv())[0] <= Max_H_azul:
                wait(5)
            car.drive_power(-15)
            wait(1500)
            block_ID, x, y, ancho, alto = Color_Bloque()
            if block_ID == 2:
                car.drive_power(0)
                car.steer(-4)
                counter_tipo_giro=2
                fin = 1
            else:
                car.steer(4)
                car.drive_power(20)
                while not Min_H_azul <= (color_sensor.hsv())[0] <= Max_H_azul:
                    wait(5)
                car.drive_power(0)
                car.steer(-5)
                counter_tipo_giro=2
                fin = 1
            print("LLegada central")
def Clock_EVASION_ROJA():
    global counter_tipo_giro, fin 
    print("Evasion roja clock")
    car.drive_power(20)

    giro_con_imu(-35, 140, 20)
    car.steer(4)
    sensor_front= Distancia_Frontal()
    while not sensor_front <=350 : #si se quiere centrar mas de cambia el valor de esto 
        sensor_front= Distancia_Frontal()

        wait(5)
    giro_con_imu(35, 96, 15)  
    car.steer(-2)
    car.drive_power(25)
    wait(250)
    print(inventor_hub.imu.heading())
    sensor_front= Distancia_Frontal()
    while not sensor_front <= 1000: #si se quiere centrar mas de cambia el valor de esto 
        sensor_front= Distancia_Frontal()
        wait(5)
    if counter_variacion_angulos >= 616:
                parqueo()
    print("ya")
    car.drive_power(15)
    giro_con_imu(-30, 115, 15)
    car.drive_power(0)
    counter_tipo_giro = 1
    fin = 1
    print("llegada esquina")
    wait(250)
def Clock_SV_V1():
    print("Clock_SV_V1")
    car.drive_power(25)
    giro_con_imu(35, 10, 25)
    car.steer(0)
    sensor_front = Distancia_Frontal()
    while not sensor_front <= 400: #si se quiere centrar mas de cambia el valor de esto 
        sensor_front = Distancia_Frontal()
        wait(0)
    giro_con_imu(-40, 90, 25)    
    car.steer(0)
    while not sensor_der.distance() < 1000:
        wait(5)
    print(sensor_der.distance())  
    giro_con_imu(-32, 140, 25)
    car.steer(0)
    sensor_front = Distancia_Frontal()
    while not sensor_front <= 600: #si se quiere centrar mas de cambia el valor de esto 
        sensor_front = Distancia_Frontal()
        wait(0)
    giro_con_imu(30, 95, 25)
    car.steer(0)
def Clock_navegacion_esquina():
    block_ID, x, y, ancho, alto = Color_Bloque()
    if block_ID == 1 and alto>50:
        print("Primera Columna VERDE")
        Clock_R_V1()#cuando primer rojo y segundo bloque es verde
        wait(250)
        Clock_Evasion()
    elif block_ID == 2 and alto>50:
        print("Primera Columna ROJA")
        Clock_R_R1()#cuando primer bloque es rojo y segundo rojo
        wait(250)
        Clock_Evasion()
    else: 
        print("Primera Columna sin Obstaculos") ##AQUI DEBE IR LA FUNCION CUANDO NO HAYA BLOQUE
        Clock_R3_N1()
        wait(250)
        Clock_Evasion()
def Clock_navegacion_central():
    block_ID, x, y, ancho, alto = Color_Bloque()
    if block_ID == 1 and alto>50:
        print("Primera Columna Verde")
        Clock_SV_V1()
        wait(100)#cuando primer bloque es verde y segundo bloque es verde
        Clock_Evasion()
    elif block_ID == 2 and alto>50:
        print("Primera Columna Roja")
        Clock_SV_R1()
        Clock_Evasion()
    else:  
        print("Primera Columna sin Obstaculos") 
        Clock_V3_N1
        Clock_Evasion()
# flujo prinicipal
######GIROS COUNTERCLOCKWISE######
muro = 0
if sensor_der.distance() < sensor_izq.distance():
    print("GIRANDO COUNTERCLOCKWISE")
    Salida_Counter()
    wait(250)
    block_ID, x, y, ancho, alto = Color_Bloque()
    print("El primer bloque al salir fue")
    print(block_ID)
    car.drive_power(0)
    block_ID, x, y, ancho, alto = Color_Bloque()
    if block_ID == 1 and alto>50:
        print("El bloque de salida fue VERDE")
        Salida_CounterV()
        Counter_navegacion_esquina()
    elif block_ID == 2 and alto>50:
        print("El Bloque de Salida fue ROJO")
        ###salida ROJA
        Salida_CounterR()#cuando primer bloque es rojo
        Counter_navegacion_central()

    else:  ####CUANDO NO VE NADA  A LA SALIDA
        print("NO HAY BLOQUE EN SALIDA")
        Salida_CounterR()
        Counter_navegacion_central()

    counter_variacion_angulos -=88
    while True:
        car.drive_power(20)
        if counter_variacion_angulos <= -300 and muro == 0:
            muro = 1
        if counter_tipo_giro == 1:
            print("El bloque de salida fue VERDE")
            print(inventor_hub.imu.heading())
            Counter_navegacion_esquina()
            counter_variacion_angulos -=88
                
        elif counter_tipo_giro == 2:
            print("El Bloque de Salida fue ROJO")
            print(inventor_hub.imu.heading())
            Counter_navegacion_central()
            counter_variacion_angulos -= 88
else:
    print("Girando Clock")
    Salida_y_lectura()
    block_ID, x, y, ancho, alto = Color_Bloque()
    if block_ID == 1 and alto > 80:
        print("Vi Verde")
        Reposicion_Verde_Medio()
        Clock_navegacion_central()
    elif block_ID == 2 and alto > 80:
        print("Vi Rojo")
        Salida_ClockR()
        Clock_navegacion_esquina()
    else:
        print("salida nada")
        Salida_ClockN() 
        wait(250)
        block_ID, x, y, ancho, alto = Color_Bloque()
        if block_ID == 1 and alto > 50:
            Reposicion_Verde2()
            Clock_R_R1()
            Clock_navegacion_central()
        elif block_ID == 2 and alto > 50:
            print("reposicion rojo 2")
            Reposicion_Rojo2()
            Clock_navegacion_esquina()
        else:
            print("no vi nada aun")
            Repocicion_Nada2()
            Clock_navegacion_central()
    counter_variacion_angulos +=88
    while True:
        car.drive_power(20)
        if counter_variacion_angulos >= 300 and muro == 0:
            muro = 1
        if counter_tipo_giro == 1:
            print("El bloque de salida fue Rojo")
            print(inventor_hub.imu.heading())
            Clock_navegacion_esquina()
            counter_variacion_angulos +=88
                
        elif counter_tipo_giro == 2:
            print("El Bloque de Salida fue Verde")
            print(inventor_hub.imu.heading())
            Clock_navegacion_central()
            counter_variacion_angulos += 88
